/*TEX
%
% IPACK - QCHEM
% Quantum Chemistry Project: Integral Package
% Copyright (C) 1994 : Wolfgang Wenzel, University of Dortmund
%
% This program is proprietary software. Unlicensed use and distribution
% of this program or parts thereof are illegal. For details on the 
% license, see the LICENSE section in the file "ipack.c" distributed 
% with this package or write to: 
%      Wolfgang Wenzel, Theoretical Physics I, 
%      University of Dortmund,
%      D-44221 Dortmund, Germany 
%
% This program is distributed in the hope that it will be useful,
% but WITHOUT ANY WARRANTY; without even the implied warranty of
% MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the LICENSE
% for more details.
%
% $Id: types.cpp,v 1.1.1.1 2008/04/08 19:44:31 igor Exp $
%
\section{Implementation of \name{Location} and \name{Momentum}} 
*/
#include "io_incl.h"
#include <errorip.h>
#include <tarray.h>
#include "typesip.h"

FlagList flaglist;

//#if !defined(_MSC_VER)
//ostream& ostream::operator<<(double d)
//{
//  char buf[100];
//  sprintf(buf," %15.6f",d);
//  return (*this) << buf;
//}
//#endif

#ifdef GNU
ostream& operator<<(ostream& os,const Array<Momentum>& dummy)
{
  error("Output for Array<Momentum> not implmeneted. ");
  return os;
}
#endif 

/*TEX
\subsection{Implementation of \name{Location}} 
*/

double Location::operator()(const Direction& d) const 
{
 switch (d)
 {
   case X: return pos[0];
   case Y: return pos[1];
   case Z: return pos[2];
 }
 return 0;
 
}

/*TEX
\subsection{Cartesian Angular Momentum}
  
Let $(x,y,z)$ be a momentum index, such that $x+y+z = L$ we wish to
concert this index into a linear index, such that the momenta are
ordered by their total L. In order to be compatible with VMOL we define
the sequence as:
\bc
\begin{tabular}{ccc|cl} 
  x   &  y  &  z  &  linear index \\
\hline
  L   &  0  &  0  &    0          &  = start(0) \\
  L-1 &  1  &  0  &    1          &  = start(1)  \\
  L-1 &  0  &  1  &    2 \\
  L-2 &  2  &  0  &    3          &  = start(2)\\
  L-2 &  1  &  1  &    4\\
  L-2 &  0  &  2  &    5\\
  L-3 &  3  &  0  &    6          &  = start(4)
\end{tabular}
\ec  
Thus:
\ba
    start(n) & = & {\rm number\ of\ momenta\ with\ x\ index\ from\ L\ 
                    to\ L-n}  \nonumber \\
             & = & \sum_{k=0}^n k \nonumber \\
             & = & n(n+1)/2 
\ea
The number of angular momenta of total momentum L is thus 
\be
  N(L) = (L+1)(L+2)/2
\ee
Therefore the starting index of the block of momenta of index L is:
\ba
{\rm MIN}(L) & = & \sum_{l=0}^{L-1} (l+1)(l+2)/2 \nonumber \\
         & = & \sum_{l=1}^{L} l(l+1)/2  \nonumber \\
         & = & 1/2 \sum_{l=1}^{L} l^2 + l \nonumber \\
         & = & 1/2\  [ L(L+1)(2L+1)/6 + L(L+1)/2 ] \nonumber \\
         & = & \frac{1}{12} L (L+1) [ (2L+1)   + 3 ] \nonumber \\
         & = & \frac{1}{6}  L (L+1) (L+2) 
\ea

\index{Momentum,index}
\index{Momentum,local\_index}

Note: The order generated by the operator++ ic compatible with 
\name{local\_index}, whicin turn is compatible with VMOL.
\index{VMOL} 
*/

int Momentum::operator++()
{
  // try to trade between y and z:
  if (yy > 0)
  {
    yy--; zz++; return 1;
  }
  else // reduce x and the y maximal 
  {
    xx--; yy = L-xx; zz = 0;
    if (xx >= 0) return 1;
  } 
  return 0;  
}

Direction Momentum::decrease() const
{
  if (xx >= yy && xx >= zz) { return X; }  
  if (yy >= xx && yy >= zz) { return Y; }  
  return Z;
}

void  Momentum::reduce(const Direction& dir)
{
  L--;
  switch(dir)
  {
  case X: xx--; break;
  case Y: yy--; break;
  case Z: zz--; break;
  }
}

void  Momentum::induce(const Direction& dir)
{
  L++;
  switch(dir)
  {
  case X: xx++; break;
  case Y: yy++; break;
  case Z: zz++; break;
  }
}

int  Momentum::operator()(const Direction& dir) const
{
  switch(dir)
  {
  case X: return xx;
  case Y: return yy;
  case Z: return zz;
  }
  return 0;
}

ostream& operator<<(ostream& os,const Location& l)
{ 
  char buffer[100];
  sprintf(buffer," (%7.3f,%7.3f,%7.3f)",l.x(),l.y(),l.z());
  return os << buffer;
}

ostream& operator<<(ostream& os,const Momentum l)
{ 
  char buffer[30];
  sprintf(buffer,"(%2i,%2i,%2i)",l.x(),l.y(),l.z()); 
  return os << buffer;
}

istream& operator>>(istream& is,Momentum& l)
{ 
  int x,y,z;
  is >> x >> y >> z;
  Momentum m(x,y,z);
  l = m;
  return is;  
}

istream& operator>>(istream& is,Location& loc)
{ 
  double x,y,z;
  is >> x >> y >> z;
  if (flaglist(Angstrom))
  {
    x /= bohr; 
    y /= bohr;
    z /= bohr; 
  }
  
  Location m(x,y,z);
  loc = m;
  return is;  
}
  

/* OLD CODE
void print(ostream& os,Direction axs)
{
}
*/

ostream& operator<<(ostream& os,Direction d)
{
 switch(d)
 {
 case X : os << 'X'; break;
 case Y : os << 'Y'; break;
 case Z : os << 'Z';
 }
 return os;
}  

istream& operator>>(istream& is,Direction& d)
{
  char c;
  is >> c;
  
  switch(c)
  {
  case 'x':
  case 'X':
    d = X;
    break;
  case 'y':
  case 'Y':
    d = Y;
    break;
  case 'z':
  case 'Z':
    d = Z;
    break;
  default:
    error("Illegal Character for Direction. ");
  }
  return is;
}

/*TEX
\subsection{Parsing Momenta from Strings}

The following function translates  a character string of the type "xxyyzzy"
containing solely the characters 'x','y' and 'z' into a cartesian momentum.

*/  

Momentum::Momentum(const char* s)
{
  xx = yy = zz = 0;
  L = strlen(s);
  for(int i=0; i < L;i++)
    switch(s[i])
    {
    case 'x': xx++; break;
    case 'y': yy++; break;
    case 'z': zz++; break;
    default:
      error(" Momentum:: Illegal Character in String. ");
    }
}

