#include <sstream>
#include <iomanip>
#include <common.hpp>
#include <object.hpp>

namespace mort
{

    namespace mdlfmt
    {
        using namespace std;
        using namespace boost;

        bool read_head( istream& is, molecule_t& mol )
        {
            char name[MAX_LINE_WIDTH];
            char supp[MAX_LINE_WIDTH];
            char null[MAX_LINE_WIDTH];
            char head[MAX_LINE_WIDTH];
        
            is.getline( name,MAX_LINE_WIDTH );
            is.getline( supp,MAX_LINE_WIDTH );
            is.getline( null,MAX_LINE_WIDTH );
            is.getline( head,MAX_LINE_WIDTH );

            if( !is )
	    {
	        return false;
	    }


            if( strlen(name) > 0 )
            {
                mol.set_s(NAME, name);
            }
	    else
	    {
	        mol.set_s(NAME, "noname" );
	    }

            int natom = atoi( head );
            int nbond = atoi( head + 3 );
        
            if( natom>=1000 || nbond >= 1000 )
            {
                throw logic_error( "mdl's sdf format doesn't support molecule > 1000 atoms" );
            }
                    
            mol.getcmp(ATOM)->resize(natom);
            mol.getcmp(BOND)->resize(nbond);

            return true;
        }
    
        void read_atom(istream& is, molecule_t& m)
        {
	    atomiter_t a = m.atom_begin();
	    for( ; a != m.atom_end(); ++a )
	    {
	        read_vparm(is, *a, POSITION, 3);
		read_sparm(is, *a, SYMBOL);
		read_iparm(is, *a, WGTDIFF);

                ostringstream name;
		name << a->get_s(SYMBOL) << a->get_i(ID);
		a->set_s( NAME, name.str() );

		is.ignore(MAX_LINE_WIDTH, '\n' );
	    }
        }        
        
        void read_bond(istream& is, molecule_t& m)
        {
	    bonditer_t b = m.bond_begin();
	    for( ; b != m.bond_end(); ++b )
	    {
	        int first, second;
		is >> first >> second;
	        b->set_a(ATOMPAIR, std::make_pair(first,second) );
		read_iparm(is, *b, ORDER);
		is.ignore(MAX_LINE_WIDTH, '\n' );
	    }
        }

        void read_chrg( istream& stream, molecule_t& mol )
        {
            mcmpdata_t* atom = mol.getcmp(ATOM);
        
            int nchg;
            stream >> nchg;
            
            for( int i=0; i < nchg; i++ )
            {
                int id;
                int fchg;
                stream >> id >> fchg;
                atom->set_i(FCHG, id-1, fchg);
            }
        }
            
        void read_info( istream& stream, molecule_t& mol )
        {
            char tag;

            for( stream >> tag; stream && tag == 'M'; stream >> tag )
            {
                string inf;
                stream >> inf;
                if( inf == "CHG" )
                {
                    read_chrg( stream, mol );
                }
            }
        
            for( ; stream && tag == '>'; stream >> tag )
            {
                string name, value;            

                stream >> tag;
                assert( tag == '<' );

                getline( stream, name );
                getline( stream, value );

                string::iterator pos = remove( name.begin(), name.end(), ' ' );

                name.erase( pos - 1, name.end() ); // delete the end '>'
         
                mol.set_s(name, value);            
            }

            if( stream && tag == '$' )
            {
                stream.ignore(MAX_LINE_WIDTH, '\n' );
            }
        
        }    
        

        void write_head( ostream& stream, const molecule_t& mol )
        {
	    string name;
            stream << ( mol.get_s(NAME, name) ? name : "untitled molecule" ) << std::endl;
            stream << "generated by mort" << std::endl;
            stream << std::endl;
            
            if( mol.natom() > 1000 || mol.nbond() > 1000 )
            {
                throw logic_error( "atom or bond number > 1000, can't dump into sdf format!" );
            }
            
            stream << std::setw(3) << mol.natom();
            stream << std::setw(3) << mol.nbond();
            stream << "  0  0  0  0  0  0  0  0  1 V2000" << std::endl;
        }
        
        void write_atom( ostream& stream, const molecule_t& mol )
        {
            atomiter_t atom = mol.atom_begin();
            
            for( ; atom != mol.atom_end(); ++atom )
            {
                write_vparm( stream, *atom, POSITION, " %9.4f");
                write_sparm( stream, *atom, SYMBOL, " %-2s");
                write_iparm( stream, *atom, WGTDIFF, " %2d");
                stream << "  0  0  0  0  0  0  0  0  0  0  0" << std::endl;
            }
        }

        typedef std::pair< int, int > ipair_t;
        
        void write_bond( ostream& stream, const molecule_t& mol )
        {
            bonditer_t bond = mol.bond_begin();
            
            for( ; bond != mol.bond_end(); ++bond )
            {
	        ipair_t ap = any_cast< ipair_t >( bond->get_a(ATOMPAIR) );
                stream << format( "%3d") % ap.first;
		stream << format( "%3d") % ap.second;

                write_iparm( stream, *bond, ORDER, "%3d");
                stream << "  0  0  0  0" << std::endl;
            }
        }
        
        void write_chrg( ostream& stream, const molecule_t& mol )
        {
            map< int, int > chrg;
            
            atomiter_t atom = mol.atom_begin();
            for( ; atom != mol.atom_end(); ++atom )
            {
	        int fchg;
                if( atom->get_i(FCHG, fchg) && fchg != 0  )
                {
		    int idx = atom - mol.atom_begin();
                    chrg[idx] = fchg;
                }
            }
            
            if( chrg.size() > 0 )
            {
                stream << "M  CHG" << std::setw(3) << chrg.size();
                
                map< int, int >::iterator i = chrg.begin();
                for( ; i != chrg.end(); ++i )
                {
                    stream << std::setw(4) << i->first + 1;
                    stream << std::setw(4) << i->second;
                }
                
                stream << std::endl;
            }
        }
        
        void write_info( ostream& stream, const molecule_t& mol )
        {
            map<hashid_t, int>::const_iterator ii = mol.ibegin();
            for( ; ii != mol.iend(); ++ii )
            {
                stream << ">  <" << unhash(ii->first) << ">" << std::endl;
                stream << ii->second << std::endl << std::endl;
            }


            map<hashid_t, double>::const_iterator di = mol.dbegin();
            for( ; di != mol.dend(); ++di )
            {
                stream << ">  <" << unhash(di->first) << ">" << std::endl;
                stream << di->second << std::endl << std::endl;
            }

            map<hashid_t, string>::const_iterator si = mol.sbegin();
            for( ; si != mol.send(); ++si )
            {
                stream << ">  <" << unhash(si->first) << ">" << std::endl;
                stream << si->second << std::endl << std::endl;
            }


        }

    } // namespace mdl

	bool read_sdf( istream& is, molecule_t& mol )
	{
		molecule_t temp;

		if( mdlfmt::read_head( is, temp) )
		{
			mdlfmt::read_atom( is, temp );

			mdlfmt::read_bond( is, temp );

			mdlfmt::read_info( is, temp );

			mol.swap( temp );
		}
		return true;
	}

    void write_sdf( ostream& os, const molecule_t& mol )
    {
        mdlfmt::write_head( os, mol );

        mdlfmt::write_atom( os, mol );
   
        mdlfmt::write_bond( os, mol );

        mdlfmt::write_chrg( os, mol );
 
        os << "M  END" << std::endl;

        mdlfmt::write_info( os, mol );

    }
    
} // namespace mort


