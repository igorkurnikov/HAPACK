#ifndef DDUTILS_MORT_MOLECULE_H
#define DDUTILS_MORT_MOLECULE_H

#include <set>
#include <boost/function.hpp>
#include "data.hpp"
#include "rela.hpp"
#include "morf.hpp"
#include "iter.hpp"
#include "root.hpp"
#include "atom.hpp"
#include "bond.hpp"
#include "resd.hpp"
#include "angl.hpp"
#include "dihe.hpp"
#include "impr.hpp"
#include "rang.hpp"

namespace mort
{

    using namespace boost;
    using std::set;

    class morf_t;

    typedef function<bool(const morf_t&)> ptrpred_t;

    /// \brief molecule_t the class representing a molecule
    /// \ingroup objdef
    ///
    /// molecule_t groups some components and adjacencies together and provides
    /// an interface to access them.
    ///
    ///  \sa component_t adjancecy_t
    class molecule_t: public root_t
    {
    public:

        /// \brief constructor
        molecule_t();

        /// \brief copy constructor
        molecule_t(const molecule_t& rhs);

        /// \brief assignment operator
        molecule_t& operator=(const molecule_t& rhs);

        /// \brief deconstructor
        virtual ~molecule_t();

        /// \brief swap the content of two molecule
        ///
        /// very useful for exceptional safety
        virtual void swap(molecule_t& rhs);

        /// \brief force get component, add new one if necessary
        /// the ID number should be generated by hash_T to avoid
        /// conflict.
        mcmpdata_t* getcmp(int cid);

        /// \brief get the component with given ID
        ///
        /// return blank component if such a component does not exist.
        mcmpdata_t const* getcmp(int cid) const;

        /// \brief get adjacency, create new one if necessary
        /// \param cid1 the first component
        /// \param cid2 the second component
        mcmprela_t* getadj(int cid1, int cid2);

        /// \brief get the adjacency for relations between components
        /// \param cid1 the first component
        /// \param cid2 the second component
        mcmprela_t const* getadj(int cid1, int cid2) const;

        ///  get the list of connected components
        bool get_nbrlist(int cid, const set<int>*& p) const;

        int nmobj( const hashid_t& id ) const { return getcmp(id)->size(); }
        int natom() const { return nmobj(ATOM); }
        int nbond() const { return nmobj(BOND); }
        int nresd() const { return nmobj(RESD); }
        int nangl() const { return nmobj(ANGL); }
        int ntors() const { return nmobj(TORS); }
        int ntor2() const { return nmobj(TOR2); }
        int noops() const { return nmobj(OOPS); }
        int nptor() const { return nmobj(PTOR); }

        mobj_range mobjs( const hashid_t& id ) const { return mobj_range(mobj_begin(id), mobj_end(id)); }
        atom_range atoms() const { return mobjs(ATOM); }
        bond_range bonds() const { return mobjs(BOND); }
        resd_range resds() const { return mobjs(RESD); }
        angl_range angls() const { return mobjs(ANGL); }
        dihe_range dihes() const { return mobjs(TORS); }
        impr_range imprs() const { return mobjs(OOPS); }
        mobj_range ptors() const { return mobjs(PTOR); }
        mobj_range tor2s() const { return mobjs(TOR2); }


        mobjiter_t mobj_begin( const hashid_t& id ) const { return mobjiter_t(morf_t(*this,id,-1), getcmp(id)->absid_begin()); }
        mobjiter_t mobj_end  ( const hashid_t& id ) const { return mobjiter_t(morf_t(*this,id,-1), getcmp(id)->absid_end()  ); }

        atomiter_t atom_begin() const { return mobj_begin(ATOM); }
        atomiter_t atom_end()   const { return mobj_end  (ATOM); }

        bonditer_t bond_begin() const { return mobj_begin(BOND); }
        bonditer_t bond_end()   const { return mobj_end  (BOND); }

        resditer_t resd_begin() const { return mobj_begin(RESD); }
        resditer_t resd_end()   const { return mobj_end  (RESD); }

        angliter_t angl_begin() const { return mobj_begin(ANGL); }
        angliter_t angl_end()   const { return mobj_end  (ANGL); }

        impriter_t impr_begin() const { return mobj_begin(OOPS); }
        impriter_t impr_end()   const { return mobj_end  (OOPS); }

        diheiter_t dihe_begin() const { return mobj_begin(TORS); }
        diheiter_t dihe_end()   const { return mobj_end  (TORS); }

        mobjiter_t tor2_begin() const { return mobj_begin(TOR2); }
        mobjiter_t tor2_end()   const { return mobj_end  (TOR2); }

        mobjiter_t ptor_begin() const { return mobj_begin(PTOR); }
        mobjiter_t ptor_end()   const { return mobj_end  (PTOR); }

        morf_t create(const hashid_t& cid);
        
        morf_t insert(const hashid_t& cid, int lid);
        morf_t insert_atom(int lid) { return insert(ATOM, lid); }
        morf_t insert_resd(int lid) { return insert(RESD, lid); }

        void remove(const morf_t& mo);
        void remove_atom(const morf_t& a);
        void remove_bond(const morf_t& b);
        void remove_resd(const morf_t& r);

        void clear();
        void cleanup();
    private:

        map<hashid_t, mcmpdata_t> m_components;
        map<hashid_t, mcmprela_t> m_adjacencys;
        map<hashid_t, set<int> > m_connecteds;
    };

    typedef shared_ptr<molecule_t> molecule_ptr;

    typedef molecule_t mole_t;

} // namespace mort

#endif

